<?php
/**
 * RsearchApi
 * PHP version 5
 *
 * @category Class
 * @package  RSearch\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ParallelStack RSearch API
 *
 * REST API Specification for ParallelStack RSearch API
 *
 * OpenAPI spec version: 1.1.0
 * Contact: team@parallelstack.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace RSearch\Client\RsearchClient;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RSearch\Client\ApiException;
use RSearch\Client\Configuration;
use RSearch\Client\HeaderSelector;
use RSearch\Client\ObjectSerializer;

/**
 * RsearchApi Class Doc Comment
 *
 * @category Class
 * @package  RSearch\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RsearchApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addDocument
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     * @param  \RSearch\Client\RSearchModel\Document $documentDetails Details of the document (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\CreateDocumentSuccess
     */
    public function addDocument($indexName, $docTypeName, $docId, $documentDetails)
    {
        list($response) = $this->addDocumentWithHttpInfo($indexName, $docTypeName, $docId, $documentDetails);
        return $response;
    }

    /**
     * Operation addDocumentWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     * @param  \RSearch\Client\RSearchModel\Document $documentDetails Details of the document (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\CreateDocumentSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function addDocumentWithHttpInfo($indexName, $docTypeName, $docId, $documentDetails)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateDocumentSuccess';
        $request = $this->addDocumentRequest($indexName, $docTypeName, $docId, $documentDetails);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocumentSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addDocumentAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     * @param  \RSearch\Client\RSearchModel\Document $documentDetails Details of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentAsync($indexName, $docTypeName, $docId, $documentDetails)
    {
        return $this->addDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId, $documentDetails)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addDocumentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     * @param  \RSearch\Client\RSearchModel\Document $documentDetails Details of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId, $documentDetails)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateDocumentSuccess';
        $request = $this->addDocumentRequest($indexName, $docTypeName, $docId, $documentDetails);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addDocument'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     * @param  \RSearch\Client\RSearchModel\Document $documentDetails Details of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addDocumentRequest($indexName, $docTypeName, $docId, $documentDetails)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling addDocument'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling addDocument'
            );
        }
        // verify the required parameter 'docId' is set
        if ($docId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docId when calling addDocument'
            );
        }
        // verify the required parameter 'documentDetails' is set
        if ($documentDetails === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documentDetails when calling addDocument'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/documents/{doc_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }
        // path params
        if ($docId !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_id' . '}',
                ObjectSerializer::toPathValue($docId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($documentDetails)) {
            $_tempBody = $documentDetails;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addDocumentType
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  \RSearch\Client\RSearchModel\DocumentType $docTypeDetails Details of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\CreateDocTypeSuccess
     */
    public function addDocumentType($indexName, $docTypeName, $docTypeDetails)
    {
        list($response) = $this->addDocumentTypeWithHttpInfo($indexName, $docTypeName, $docTypeDetails);
        return $response;
    }

    /**
     * Operation addDocumentTypeWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  \RSearch\Client\RSearchModel\DocumentType $docTypeDetails Details of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\CreateDocTypeSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function addDocumentTypeWithHttpInfo($indexName, $docTypeName, $docTypeDetails)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateDocTypeSuccess';
        $request = $this->addDocumentTypeRequest($indexName, $docTypeName, $docTypeDetails);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocTypeSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addDocumentTypeAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  \RSearch\Client\RSearchModel\DocumentType $docTypeDetails Details of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentTypeAsync($indexName, $docTypeName, $docTypeDetails)
    {
        return $this->addDocumentTypeAsyncWithHttpInfo($indexName, $docTypeName, $docTypeDetails)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addDocumentTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  \RSearch\Client\RSearchModel\DocumentType $docTypeDetails Details of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentTypeAsyncWithHttpInfo($indexName, $docTypeName, $docTypeDetails)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateDocTypeSuccess';
        $request = $this->addDocumentTypeRequest($indexName, $docTypeName, $docTypeDetails);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addDocumentType'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  \RSearch\Client\RSearchModel\DocumentType $docTypeDetails Details of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addDocumentTypeRequest($indexName, $docTypeName, $docTypeDetails)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling addDocumentType'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling addDocumentType'
            );
        }
        // verify the required parameter 'docTypeDetails' is set
        if ($docTypeDetails === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeDetails when calling addDocumentType'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($docTypeDetails)) {
            $_tempBody = $docTypeDetails;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addIndex
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\CreateIndexSuccess
     */
    public function addIndex($indexName)
    {
        list($response) = $this->addIndexWithHttpInfo($indexName);
        return $response;
    }

    /**
     * Operation addIndexWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\CreateIndexSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function addIndexWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateIndexSuccess';
        $request = $this->addIndexRequest($indexName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateIndexSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\CreateIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addIndexAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addIndexAsync($indexName)
    {
        return $this->addIndexAsyncWithHttpInfo($indexName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addIndexAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addIndexAsyncWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\CreateIndexSuccess';
        $request = $this->addIndexRequest($indexName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addIndex'
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addIndexRequest($indexName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling addIndex'
            );
        }

        $resourcePath = '/indexes/{index_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocument
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\DeleteDocumentSuccess
     */
    public function deleteDocument($indexName, $docTypeName, $docId)
    {
        list($response) = $this->deleteDocumentWithHttpInfo($indexName, $docTypeName, $docId);
        return $response;
    }

    /**
     * Operation deleteDocumentWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\DeleteDocumentSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentWithHttpInfo($indexName, $docTypeName, $docId)
    {
        $returnType = '\RSearch\Client\RSearchModel\DeleteDocumentSuccess';
        $request = $this->deleteDocumentRequest($indexName, $docTypeName, $docId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteDocumentSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsync($indexName, $docTypeName, $docId)
    {
        return $this->deleteDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId)
    {
        $returnType = '\RSearch\Client\RSearchModel\DeleteDocumentSuccess';
        $request = $this->deleteDocumentRequest($indexName, $docTypeName, $docId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocument'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentRequest($indexName, $docTypeName, $docId)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling deleteDocument'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling deleteDocument'
            );
        }
        // verify the required parameter 'docId' is set
        if ($docId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docId when calling deleteDocument'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/documents/{doc_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }
        // path params
        if ($docId !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_id' . '}',
                ObjectSerializer::toPathValue($docId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteIndex
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\DeleteIndexSuccess
     */
    public function deleteIndex($indexName)
    {
        list($response) = $this->deleteIndexWithHttpInfo($indexName);
        return $response;
    }

    /**
     * Operation deleteIndexWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\DeleteIndexSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteIndexWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\DeleteIndexSuccess';
        $request = $this->deleteIndexRequest($indexName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteIndexSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\DeleteIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteIndexAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIndexAsync($indexName)
    {
        return $this->deleteIndexAsyncWithHttpInfo($indexName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteIndexAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIndexAsyncWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\DeleteIndexSuccess';
        $request = $this->deleteIndexRequest($indexName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteIndex'
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteIndexRequest($indexName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling deleteIndex'
            );
        }

        $resourcePath = '/indexes/{index_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvancedDocTypeSuggestResults
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $suggest Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\SuggestSuccess
     */
    public function getAdvancedDocTypeSuggestResults($indexName, $docTypeName, $suggest)
    {
        list($response) = $this->getAdvancedDocTypeSuggestResultsWithHttpInfo($indexName, $docTypeName, $suggest);
        return $response;
    }

    /**
     * Operation getAdvancedDocTypeSuggestResultsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $suggest Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\SuggestSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvancedDocTypeSuggestResultsWithHttpInfo($indexName, $docTypeName, $suggest)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getAdvancedDocTypeSuggestResultsRequest($indexName, $docTypeName, $suggest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvancedDocTypeSuggestResultsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $suggest Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedDocTypeSuggestResultsAsync($indexName, $docTypeName, $suggest)
    {
        return $this->getAdvancedDocTypeSuggestResultsAsyncWithHttpInfo($indexName, $docTypeName, $suggest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvancedDocTypeSuggestResultsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $suggest Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedDocTypeSuggestResultsAsyncWithHttpInfo($indexName, $docTypeName, $suggest)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getAdvancedDocTypeSuggestResultsRequest($indexName, $docTypeName, $suggest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvancedDocTypeSuggestResults'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $suggest Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvancedDocTypeSuggestResultsRequest($indexName, $docTypeName, $suggest)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getAdvancedDocTypeSuggestResults'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getAdvancedDocTypeSuggestResults'
            );
        }
        // verify the required parameter 'suggest' is set
        if ($suggest === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $suggest when calling getAdvancedDocTypeSuggestResults'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($suggest)) {
            $_tempBody = $suggest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvancedIndexSuggestResults
     *
     * @param  string $indexName Name of the index (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $search Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\SuggestSuccess
     */
    public function getAdvancedIndexSuggestResults($indexName, $search)
    {
        list($response) = $this->getAdvancedIndexSuggestResultsWithHttpInfo($indexName, $search);
        return $response;
    }

    /**
     * Operation getAdvancedIndexSuggestResultsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $search Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\SuggestSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvancedIndexSuggestResultsWithHttpInfo($indexName, $search)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getAdvancedIndexSuggestResultsRequest($indexName, $search);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvancedIndexSuggestResultsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedIndexSuggestResultsAsync($indexName, $search)
    {
        return $this->getAdvancedIndexSuggestResultsAsyncWithHttpInfo($indexName, $search)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvancedIndexSuggestResultsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedIndexSuggestResultsAsyncWithHttpInfo($indexName, $search)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getAdvancedIndexSuggestResultsRequest($indexName, $search);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvancedIndexSuggestResults'
     *
     * @param  string $indexName Name of the index (required)
     * @param  \RSearch\Client\RSearchModel\SuggestQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvancedIndexSuggestResultsRequest($indexName, $search)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getAdvancedIndexSuggestResults'
            );
        }
        // verify the required parameter 'search' is set
        if ($search === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search when calling getAdvancedIndexSuggestResults'
            );
        }

        $resourcePath = '/indexes/{index_name}/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($search)) {
            $_tempBody = $search;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvancedSearchResults
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SearchQuery $search Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\SearchSuccess
     */
    public function getAdvancedSearchResults($indexName, $docTypeName, $search)
    {
        list($response) = $this->getAdvancedSearchResultsWithHttpInfo($indexName, $docTypeName, $search);
        return $response;
    }

    /**
     * Operation getAdvancedSearchResultsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SearchQuery $search Details of the search query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\SearchSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvancedSearchResultsWithHttpInfo($indexName, $docTypeName, $search)
    {
        $returnType = '\RSearch\Client\RSearchModel\SearchSuccess';
        $request = $this->getAdvancedSearchResultsRequest($indexName, $docTypeName, $search);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvancedSearchResultsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SearchQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedSearchResultsAsync($indexName, $docTypeName, $search)
    {
        return $this->getAdvancedSearchResultsAsyncWithHttpInfo($indexName, $docTypeName, $search)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvancedSearchResultsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SearchQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvancedSearchResultsAsyncWithHttpInfo($indexName, $docTypeName, $search)
    {
        $returnType = '\RSearch\Client\RSearchModel\SearchSuccess';
        $request = $this->getAdvancedSearchResultsRequest($indexName, $docTypeName, $search);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvancedSearchResults'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  \RSearch\Client\RSearchModel\SearchQuery $search Details of the search query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvancedSearchResultsRequest($indexName, $docTypeName, $search)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getAdvancedSearchResults'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getAdvancedSearchResults'
            );
        }
        // verify the required parameter 'search' is set
        if ($search === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search when calling getAdvancedSearchResults'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($search)) {
            $_tempBody = $search;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllDocumentTypes
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetDocTypesSuccess
     */
    public function getAllDocumentTypes($indexName)
    {
        list($response) = $this->getAllDocumentTypesWithHttpInfo($indexName);
        return $response;
    }

    /**
     * Operation getAllDocumentTypesWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetDocTypesSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllDocumentTypesWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocTypesSuccess';
        $request = $this->getAllDocumentTypesRequest($indexName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypesSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllDocumentTypesAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDocumentTypesAsync($indexName)
    {
        return $this->getAllDocumentTypesAsyncWithHttpInfo($indexName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllDocumentTypesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDocumentTypesAsyncWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocTypesSuccess';
        $request = $this->getAllDocumentTypesRequest($indexName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllDocumentTypes'
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllDocumentTypesRequest($indexName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getAllDocumentTypes'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllDocuments
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetDocumentsSuccess
     */
    public function getAllDocuments($indexName, $docTypeName)
    {
        list($response) = $this->getAllDocumentsWithHttpInfo($indexName, $docTypeName);
        return $response;
    }

    /**
     * Operation getAllDocumentsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetDocumentsSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllDocumentsWithHttpInfo($indexName, $docTypeName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocumentsSuccess';
        $request = $this->getAllDocumentsRequest($indexName, $docTypeName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentsSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentsFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentsFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentsFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentsFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllDocumentsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDocumentsAsync($indexName, $docTypeName)
    {
        return $this->getAllDocumentsAsyncWithHttpInfo($indexName, $docTypeName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllDocumentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDocumentsAsyncWithHttpInfo($indexName, $docTypeName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocumentsSuccess';
        $request = $this->getAllDocumentsRequest($indexName, $docTypeName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllDocuments'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllDocumentsRequest($indexName, $docTypeName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getAllDocuments'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getAllDocuments'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllIndexes
     *
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetIndexesSuccess
     */
    public function getAllIndexes()
    {
        list($response) = $this->getAllIndexesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAllIndexesWithHttpInfo
     *
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetIndexesSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllIndexesWithHttpInfo()
    {
        $returnType = '\RSearch\Client\RSearchModel\GetIndexesSuccess';
        $request = $this->getAllIndexesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexesSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexesFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllIndexesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllIndexesAsync()
    {
        return $this->getAllIndexesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllIndexesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllIndexesAsyncWithHttpInfo()
    {
        $returnType = '\RSearch\Client\RSearchModel\GetIndexesSuccess';
        $request = $this->getAllIndexesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllIndexes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllIndexesRequest()
    {

        $resourcePath = '/indexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBasicSearchResults
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $q Search Query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\SearchSuccess
     */
    public function getBasicSearchResults($indexName, $q)
    {
        list($response) = $this->getBasicSearchResultsWithHttpInfo($indexName, $q);
        return $response;
    }

    /**
     * Operation getBasicSearchResultsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $q Search Query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\SearchSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBasicSearchResultsWithHttpInfo($indexName, $q)
    {
        $returnType = '\RSearch\Client\RSearchModel\SearchSuccess';
        $request = $this->getBasicSearchResultsRequest($indexName, $q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SearchFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBasicSearchResultsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $q Search Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicSearchResultsAsync($indexName, $q)
    {
        return $this->getBasicSearchResultsAsyncWithHttpInfo($indexName, $q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBasicSearchResultsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $q Search Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicSearchResultsAsyncWithHttpInfo($indexName, $q)
    {
        $returnType = '\RSearch\Client\RSearchModel\SearchSuccess';
        $request = $this->getBasicSearchResultsRequest($indexName, $q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBasicSearchResults'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $q Search Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBasicSearchResultsRequest($indexName, $q)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getBasicSearchResults'
            );
        }
        // verify the required parameter 'q' is set
        if ($q === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling getBasicSearchResults'
            );
        }

        $resourcePath = '/indexes/{index_name}/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }

        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocTypeSuggestResults
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  string $q Details of the suggest query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\SuggestSuccess
     */
    public function getDocTypeSuggestResults($indexName, $docTypeName, $q)
    {
        list($response) = $this->getDocTypeSuggestResultsWithHttpInfo($indexName, $docTypeName, $q);
        return $response;
    }

    /**
     * Operation getDocTypeSuggestResultsWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  string $q Details of the suggest query (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\SuggestSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocTypeSuggestResultsWithHttpInfo($indexName, $docTypeName, $q)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getDocTypeSuggestResultsRequest($indexName, $docTypeName, $q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\SuggestFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocTypeSuggestResultsAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  string $q Details of the suggest query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocTypeSuggestResultsAsync($indexName, $docTypeName, $q)
    {
        return $this->getDocTypeSuggestResultsAsyncWithHttpInfo($indexName, $docTypeName, $q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocTypeSuggestResultsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  string $q Details of the suggest query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocTypeSuggestResultsAsyncWithHttpInfo($indexName, $docTypeName, $q)
    {
        $returnType = '\RSearch\Client\RSearchModel\SuggestSuccess';
        $request = $this->getDocTypeSuggestResultsRequest($indexName, $docTypeName, $q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocTypeSuggestResults'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the Document_type (required)
     * @param  string $q Details of the suggest query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocTypeSuggestResultsRequest($indexName, $docTypeName, $q)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getDocTypeSuggestResults'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getDocTypeSuggestResults'
            );
        }
        // verify the required parameter 'q' is set
        if ($q === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling getDocTypeSuggestResults'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }

        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetDocumentSuccess
     */
    public function getDocument($indexName, $docTypeName, $docId)
    {
        list($response) = $this->getDocumentWithHttpInfo($indexName, $docTypeName, $docId);
        return $response;
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetDocumentSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($indexName, $docTypeName, $docId)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocumentSuccess';
        $request = $this->getDocumentRequest($indexName, $docTypeName, $docId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocumentFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($indexName, $docTypeName, $docId)
    {
        return $this->getDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($indexName, $docTypeName, $docId)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocumentSuccess';
        $request = $this->getDocumentRequest($indexName, $docTypeName, $docId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     * @param  string $docId Document ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRequest($indexName, $docTypeName, $docId)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getDocument'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getDocument'
            );
        }
        // verify the required parameter 'docId' is set
        if ($docId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docId when calling getDocument'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}/documents/{doc_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }
        // path params
        if ($docId !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_id' . '}',
                ObjectSerializer::toPathValue($docId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentType
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetDocTypeSuccess
     */
    public function getDocumentType($indexName, $docTypeName)
    {
        list($response) = $this->getDocumentTypeWithHttpInfo($indexName, $docTypeName);
        return $response;
    }

    /**
     * Operation getDocumentTypeWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetDocTypeSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentTypeWithHttpInfo($indexName, $docTypeName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocTypeSuccess';
        $request = $this->getDocumentTypeRequest($indexName, $docTypeName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypeSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetDocTypeFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentTypeAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTypeAsync($indexName, $docTypeName)
    {
        return $this->getDocumentTypeAsyncWithHttpInfo($indexName, $docTypeName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTypeAsyncWithHttpInfo($indexName, $docTypeName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetDocTypeSuccess';
        $request = $this->getDocumentTypeRequest($indexName, $docTypeName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentType'
     *
     * @param  string $indexName Name of the index (required)
     * @param  string $docTypeName Name of the document_type (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentTypeRequest($indexName, $docTypeName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getDocumentType'
            );
        }
        // verify the required parameter 'docTypeName' is set
        if ($docTypeName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docTypeName when calling getDocumentType'
            );
        }

        $resourcePath = '/indexes/{index_name}/document_types/{doc_type_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }
        // path params
        if ($docTypeName !== null) {
            $resourcePath = str_replace(
                '{' . 'doc_type_name' . '}',
                ObjectSerializer::toPathValue($docTypeName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIndex
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RSearch\Client\RSearchModel\GetIndexSuccess
     */
    public function getIndex($indexName)
    {
        list($response) = $this->getIndexWithHttpInfo($indexName);
        return $response;
    }

    /**
     * Operation getIndexWithHttpInfo
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \RSearch\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RSearch\Client\RSearchModel\GetIndexSuccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIndexWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetIndexSuccess';
        $request = $this->getIndexRequest($indexName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexSuccess',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RSearch\Client\RSearchModel\GetIndexFailure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIndexAsync
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIndexAsync($indexName)
    {
        return $this->getIndexAsyncWithHttpInfo($indexName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIndexAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIndexAsyncWithHttpInfo($indexName)
    {
        $returnType = '\RSearch\Client\RSearchModel\GetIndexSuccess';
        $request = $this->getIndexRequest($indexName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIndex'
     *
     * @param  string $indexName Name of the index (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIndexRequest($indexName)
    {
        // verify the required parameter 'indexName' is set
        if ($indexName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indexName when calling getIndex'
            );
        }

        $resourcePath = '/indexes/{index_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($indexName !== null) {
            $resourcePath = str_replace(
                '{' . 'index_name' . '}',
                ObjectSerializer::toPathValue($indexName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('auth_token');
        if ($apiKey !== null) {
            $queryParams['auth_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-RSearch-App-ID');
        if ($apiKey !== null) {
            $headers['X-RSearch-App-ID'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
